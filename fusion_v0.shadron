//Global illumination
#include <math_constants>
#define π PI
#define τ TAU
#define φ 1.61803398875
#define IOR 1.333

image noise =		file("blunoize_n&b.png")  : hidden();
image normal_noise = file("blunoize_norm.png") : hidden();
image albedo =	   file ("albedo.png")	   : hidden();
image skysphere =	file("sphere_skybox_alt.png");
image depth =		file("depth.png")		 : hidden();
image norm =		 file("norm.png")		  : hidden();
image spec =		 file("spec.png")		  : hidden();
image light =		file("self.png")		  : hidden();

param bool  moving_light = true;
param bool  shadows = true;
param bool  advanced_ssao		= false;

param float scale			  = .5   : range(.1, 1);

param float γ				  = 2.2  : range(1., 3.);
param float speed			  = .01  : range(0., .1);
param float persp_corr		 = 0.2;

// light
param vec3  light_place = vec3(.5,.65,.5);
glsl  vec3  light_intensity = vec3(.8,.8,.8);
param float light_str = .2 : range(0., 1.);
// Screen space shadow
param float dither  = 1.;

param int   big_steps = 10 : logrange (1, 100);
param float depth_tolerance_light = .02 : range (0.,.01);
param float depth_threshold_light = .1 : range(0.,.3);



// Noise function :
// texture(noise, (scale*2*pos*sizeof(diffuse)+floor(sizeof(noise)*vec2((sin(1000*time)),(cos(1000*time)))))/sizeof(noise)).g

glsl float sqdist(vec3 a, vec3 b){
	a-=b;
	a*=a;
	return a.x + a.y + a.z;
}


glsl vec3 linearize(vec3 col){
	return vec3(
		pow(col.r, γ),
		pow(col.g, γ),
		pow(col.b, γ));
}


glsl vec3 delinearize(vec3 col){
	return vec3(
		pow(col.r, 1./γ),
		pow(col.g, 1./γ),
		pow(col.b, 1./γ));
}




glsl vec3 get_albedo(vec2 position){
	return linearize(texture(albedo, position).rgb);
}

glsl vec3 get_normal(vec2 position){
	return texture(norm, position).rgb-.5;
}

glsl float get_roughness(vec2 position){
	return .0001 + texture(spec, position).r*texture(spec, position).r;
}


/* Material models */

//Diffuse
glsl float lambert(vec3 l, vec3 n){
	return max(0., dot(l, n));
}

glsl float oren_nayar(vec3 l, vec3 n, float σ){//vec v ?
	// Direction toward the viewer
	vec3 v = vec3(0,0,1);
	// Taken from http://shaderjvo.blogspot.com/2011/08/van-ouwerkerks-rewrite-of-oren-nayar.html
	// Equivalent to Oren Nayar.
	// Maybe consider this improved oren-nayar for later use :
	// http://mimosa-pudica.net/improved-oren-nayar.html

	float σ² = σ * σ;
	vec2 oren_nayar_fraction = σ² / (σ² + vec2(0.33, 0.09));
	vec2 oren_nayar = vec2(1, 0) + vec2(-0.5, 0.45) * oren_nayar_fraction;
	// Theta and phi
	vec2 cosθ  = clamp(vec2(dot(n, l), dot(n, v)), 0, 1);
	vec2 cosθ² = cosθ * cosθ;
	float sinθ = sqrt((1-cosθ².x) * (1-cosθ².y));

	vec3 light_plane = normalize(l - cosθ.x * n);
	vec3 view_plane  = normalize(v - cosθ.y * n);
	float cosΦ = clamp(dot(light_plane, view_plane), 0, 1);

	float diffuse_oren_nayar = cosΦ * sinθ / max(cosθ.x, cosθ.y);
	float diffuse_light = cosθ.x * (oren_nayar.x + oren_nayar.y * diffuse_oren_nayar);

	return diffuse_light;
}

glsl float blinn_phong(vec3 l, vec3 n, float σ){
	if(dot(l, n) < 0){
		return 0.;
	}
    // Direction toward the viewer
    vec3 v = vec3(0, 0, 1);
	// Average of viewer and light direction
	vec3 h = normalize(l + v);
	float shininess = 2./(σ*σ) - 2.;
	// 4 times the phong shininess
	return pow(max(0, dot(h, n)), 4 * shininess);

}

//Specular
glsl float modified_blinn_phong(vec3 l, vec3 n, float σ){

	if(dot(l, n) < 0){
		return 0.;
	}
	// Direction toward the viewer
	vec3 v = vec3(0, 0, 1);
	// Average of viewer and light direction
	vec3 h = normalize(l + v);


	// custom part
	float shininess = .5/(σ*σ) -.5;
	float multiplier = 2.5*(IOR-1)*pow(1+σ,-10);

	// 4 times the phong shininess
	return 1000*multiplier*pow(max(0, dot(h, n)), 4 * shininess);

}

// /!\ HEAVY /!\
// x component for the specular reflection
// the y component is for light which will be used by the diffuse
glsl vec2 cook_torrance(vec3 l, vec3 n, float σ){

	// Direction toward the viewer
	vec3 v = vec3(0, 0, 1);
	// Average of viewer and light direction
	vec3 h = normalize(l + v);

	float HdotN = dot(h, n);
	float VdotN = dot(v, n);
	float LdotN = dot(l, n);
	float VdotH = dot(v, h);

	if(LdotN < 0){
		return vec2(0, 1);
	}

	//Precalculations for Beckmann
	float m² = σ * σ;//m is the rms of surface microfacet, which is σ, the standard deviation of our gaussian distribution of microfacets
	// α is never directly used, only cos²α in our simplified formula
	// So we can replace cos²α with HdotN²
	float cos²α = HdotN * HdotN; //Equivalent but less costly

	float cos⁴α = cos²α * cos²α;
	float tan²α_over_m² = (1 - cos²α) / (cos²α * m²);
	// Beckmann distribution
	float D = exp(-tan²α_over_m²) / (π * m² * cos⁴α);

	// Fresnel
	// using Schlick's approximation

	float n₁ = 1.00029;//Air
	float n₂ = IOR;

	float R₀ = (n₁ - n₂) / (n₁ + n₂);
	R₀ *= R₀;
	float schlick = R₀ + (1 - R₀) * pow(1 - VdotN, 5);
	float F = schlick;

	// Geometric attenuation term.
	// Can probably be simplified a lot, only difference being VdotN or LdotN
	float G = min(
		1,
		min(
			2 * HdotN * VdotN / VdotH,
			2 * HdotN * LdotN / VdotH
			)
		);
	float final = D * F * G / (4 * VdotN * LdotN);
	return vec2(final, 1 - F);// Return as y the complementary to Fresnel to use for diffuse illum
}


/*
glsl float light_orb(vec3(pos)){
	float strength = 10. ;
		for(int i=0;i<nb_spheres;i++){
			col = texture(Colind, vec2((float (i))*0.01,(float(i))*0.02));
			couleur += col*strengh/sqdist(vec3(pos.xy, 0), )),
						sin(time*perlinNoise(vec2(1.2*i+5.5)))));
		}
}
*/
glsl bool raybtween(vec3 a, vec3 b, vec2 pos, float time){
	vec3 curr_place = a;
	float curr_depth = 0.;
	float myrand = dither*texture(noise, (scale*pos*sizeof(albedo)+floor(sizeof(noise)*vec2((sin(1000*time)),(cos(1000*time)))))/sizeof(noise)).g;

	for(int i=0; i<big_steps; i++){

		//eco de mémoire : utilisation de curr_depth pour le mix
		curr_depth = (i+myrand)/float(big_steps);
		curr_place = mix(a, b,curr_depth);
		//fixe au pixel le plus proche
		curr_place.xy = (floor(curr_place.xy*sizeof(depth)))/sizeof(depth);


		//Dès qu'on sort, c'est bon.
		if(	curr_place.x <= 0. || curr_place.x >= 1.
			|| curr_place.y <= 0. || curr_place.y >= 1.
			|| curr_place.z <= 0. || curr_place.z >= 1.
		){return true;}

		//Collision
		curr_depth = texture(
			depth,
			(curr_place.xy)).g;
		if ( curr_depth > curr_place.z + depth_tolerance_light
			&& curr_depth < curr_place.z + depth_threshold_light
		){return false;}

	}

	return true;
}


glsl vec3 get_light_place(float time){
	if(moving_light){
		return light_place + vec3(.1*cos(.5*time),.1*sin(.3*time),.2*sin(.2*time));
	}else{
		return light_place;
	}
}

glsl vec3 direct_lighting(vec2 pos, float time){
	float depth = texture(depth, pos).g;
	//Juste pour l'animation
	vec3 new_place = get_light_place(time);
	vec3 l = normalize(new_place-vec3(pos,depth));
	vec3 n = get_normal(pos);
	float diffuse_str = lambert(l, n);
	vec2 cook = cook_torrance(l, n, get_roughness(pos));
	float spec_str = cook.x;
	// diffuse_str *= cook.y;a
	float sqdist = sqdist(new_place, vec3(pos, depth));
	vec3 color = light_str*light_intensity*(spec_str + get_albedo(pos)*diffuse_str)/sqdist;
	if(color.r <= 0 && color.g <= 0 && color.b <= 0){
		return vec3(0.);
	}

	if(shadows){
		if (raybtween(vec3(pos, depth),new_place, pos, time)){
			return vec3(delinearize(color));
		}else{
			return vec3(0.);
		}
	}else{
		return delinearize(color);
	}
}

animation lighted =glsl(direct_lighting, scale*sizeof(albedo));


glsl vec3 ray_launch(vec3 pos, vec3 dir, float time){

	vec3 curr_place;
	vec3 corr_dir = dir + vec3((pos.xy-.5)*persp_corr,0.);
	float curr_depth ;
	float i_float=0;
	for(int i=0; i<steps_gi; i++){
		i_float = i + texture(noise, (corr_dir.xy*sizeof(albedo)+floor(sizeof(noise) * vec2((sin(1000*time)), (cos(1000*time)) )))/sizeof(noise)).g;
		curr_place = pos + (i_float*speed + accel*pow(i_float, 2.))*corr_dir;

		//Dès qu'on sort, skysphere
		if(curr_place.x < 0. || curr_place.x > 1.
		|| curr_place.y < 0. || curr_place.y > 1.
		|| curr_place.z < 0. || curr_place.z > 1.
		){
			return linearize(texture(skysphere, dir.xy+.5).rgb);
		}

		curr_depth = texture(depth, curr_place.xy).g;
		//Si on se prend qqchose
		if (curr_depth > curr_place.z + depth_tolerance_gi){
			if(curr_depth < curr_place.z + depth_threshold_gi){
				return linearize(texture(lighted, curr_place.xy).rgb);
			}else{
				return vec3(0.);
			}
		}
	}
	return linearize(texture(skysphere, dir.xy+.5).rgb);
}


glsl vec3 skysphere_illum (vec2 pos, float time){
	vec3 total_light = vec3(0.);
	vec3 norm_ray = normalize(texture(norm, pos).xyz-.5);
	vec3 norm_rand =
		1.*(texture(normal_noise,
			(pos*sizeof(albedo)+floor(sizeof(normal_noise)*vec2((sin(1000*time)),(cos(1000*time)))))/sizeof(noise)).xyz-.5);

	vec3 norm_launch;
	for(int x=0; x<nb_steps; x++){
		for(int y=0; y<nb_steps; y++){
			norm_launch = (vec3(x, y,1.)+.5+norm_rand)/nb_steps-.5;
			norm_launch.z = 1.-pow(norm_launch.x*norm_launch.x+norm_launch.y*norm_launch.y,.5);
			norm_launch = .5+.5*
				normalize (
				norm_ray + norm_launch);
			if (advanced_ssao) {
				if(norm_launch.z>0.){
					total_light += ray_launch(vec3(pos, (texture(depth, pos).g)), (norm_launch-.5), time);
				}else{
					return vec3(0.);
				}
			} else {
				if(norm_launch.z>0.){
					total_light += texture(skysphere, norm_launch.xy).rgb;
				}else{
					return vec3(0.);
				}
			}
		}
	}
	return delinearize(total_light/float((nb_steps)*(nb_steps)));
}

// animation sky_ill = glsl(skysphere_illum, scale*sizeof(albedo));

glsl vec3 fus (vec2 pos){
	return delinearize(linearize(texture(albedo, pos).rgb)*linearize(texture(sky_ill, pos).rgb) + linearize(texture(lighted, pos).rgb));
}



//Copycut sale
glsl vec3 final_light(vec2 pos, float time){
	vec3 total_light = vec3(0.);
	vec3 norm_ray = normalize(texture(norm, pos).xyz-.5);
	vec3 norm_rand =
		1.*(texture(normal_noise,
			(scale*pos*sizeof(albedo)+floor(sizeof(normal_noise)*vec2((sin(1000*time)),(cos(1000*time)))))/sizeof(noise)).xyz-.5);

	total_light *= linearize(texture(albedo, pos).rgb);
	total_light += linearize(fus(pos).rgb);
	total_light += linearize(texture(light, pos).rgb);
	return delinearize(total_light);
}

// animation second = glsl(final_light, scale*sizeof(albedo));
